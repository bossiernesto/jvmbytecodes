//package exe.jvmbytecode;

import java.io.IOException;
import java.lang.InterruptedException;
import java.io.File;
import java.io.FilenameFilter;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;;

class GenerateBytecodes
{
    static long timeStamp;
    static BufferedReader br;
    public static Class_[] classes;

    public static void main(String[] args)
    {
	timeStamp = System.currentTimeMillis();
	String path = args[0];
	String sourceFileName = args[1];
	String[] newClassFiles = compile(path , sourceFileName );
	if (newClassFiles == null)
	    // should not get here	    
	    System.out.println( "No class files were generated" );
	else 
	{
	    //System.out.println( newClassFiles.length );
	    classes = new Class_[newClassFiles.length];
	    for(int i=0; i<newClassFiles.length; i++)
	    {
		if (newClassFiles[i].startsWith("Error message"))
		{
		    System.out.println( newClassFiles[i] );
		    System.exit(1);
		}
		else {
		    try {
			classes[i] = load_bytecodes( path, newClassFiles[i] );
		    } catch (InvalidClassFileException e) {
			System.out.println("Your Java code does not " +
					   "satisfy the constraints of the " +
					   "simulator:\n" + "    " + e);
			System.exit(1);
		    }
		    //System.out.println( classes[i] );
		    if (classes[i] == null)
		    {
			System.out.println( "Could not load bytecodes" );
			break;
		    }
		}// no error during compilation
	    }
	    System.out.println(classes[0]);
	}
    }// main method

    /** Returns the list of names of the class files generated by
     *  compiling the Java source code file named "path/fileName"
     */
    public static String[] compile(String path, String fileName)
    {
	long timeStamp = System.currentTimeMillis();
	Process javac = null;
	int javacStatus;
	try {
	    String javacCommand = 
                 "javac -g " + path + "/" + fileName;
	    javac = Runtime.getRuntime().exec( javacCommand );
	} catch (IOException e) {
	    return new String[]{"Error message 1"};
	}
	try {
	    javacStatus = javac.waitFor();
	} catch (InterruptedException e) {
	    return new String[]{"Error message 2"};
	}
	if (javacStatus == 0) {   // no compilation error
	    return new File(path).list( new ClassNameFilter() );
	}
	else {
	    return new String[]{"Error message 3"};
	}
    }// compile method


    public static Class_ load_bytecodes( String path, String classFileName )
	throws InvalidClassFileException
    {
	Process javap = null;
	int javapStatus;
	classFileName = classFileName.substring(0,classFileName.length()-6);
	try {
	    String javapCommand = 
		"javap -verbose -private " + path + "/" + classFileName ;
	    javap = Runtime.getRuntime().exec( javapCommand );
	} catch (IOException e) {
	    e.printStackTrace();
	    return null;
	}

	br = new BufferedReader(new InputStreamReader(javap.getInputStream()));
	String line;
	Class_ c = null;
	try {
	    c = loadClass();
	} catch (IOException e) {
	    e.printStackTrace();
	}
	return c;
    }

    private static Class_ loadClass() throws IOException, 
					     InvalidClassFileException 
    {
	String line = br.readLine(); // skip "Compiled from" line
	Class_ c = parseClassNameAndSuperName();
	parseSourceFileName( c );
	skipConstantPool();
	line = parseFields(c);
	parseMethods( line, c );
	return c;
    }// loadClass method

    private static Class_ parseClassNameAndSuperName() 
	throws IOException, InvalidClassFileException 
    {
	String line = br.readLine().trim();
	int implementsIndex = line.indexOf( "implements" );
	if (implementsIndex != -1)
	    line = line.substring(0,implementsIndex);

	int classIndex = line.indexOf( "class" );
	String classModifiers = null;
	if (classIndex > 0)
	{
	    classModifiers = line.substring(0,classIndex-1);
	    if (classModifiers.contains("abstract"))
		throw new InvalidClassFileException(
		       "Abstract classes are not supported");
		
	    line = line.substring(classIndex);
	}
	else {
	    if 	(line.indexOf( "interface " ) >= 0)
		throw new InvalidClassFileException(
				 "Interfaces are not supported");
	}

	String[] tokens = line.split("\\s+");
	int lastDotPosition = tokens[1].lastIndexOf(".");
	String packageName = null;
	String className = null;
	if (lastDotPosition == -1) 
	{
	    className = tokens[1];
	}
	else
	{
	    packageName = tokens[1].substring(0,lastDotPosition);
	    className = tokens[1].substring(lastDotPosition+1);
	}

	String superName = tokens[3];
	return new Class_(classModifiers, packageName,className,superName);
    }// parseClassNameAndSuperName method

    private static void parseSourceFileName(Class_ c) 
	throws IOException,
	       InvalidClassFileException 
    {
	String[] tokens = br.readLine().trim().split("\\s+");
	c.setSourceFileName( tokens[1].substring(1,tokens[1].length()-1) );
    }// parseSourceFileName method


    private static void skipConstantPool() throws IOException,
						  InvalidClassFileException 
    {
	String line;
	do { 
	    line = br.readLine().trim();
	    if (line.startsWith("InnerClass:"))
		throw new InvalidClassFileException(
			   "Inner classes are not supported");
	} while  (!line.equals("{"));
    }// skipConstantPool method

    private static String skipEmptyOrIndentedLines() 	
	throws IOException
    {
	String line;
	do
	    line = br.readLine();
	while ( (line.equals("")) || (line.startsWith(" ")) );
	return line;
    }

    private static String skipUntilLVTorNonIndentedLine() 	
	throws IOException
    {
	String line;
	do
	    line = br.readLine();
	while ( ( ! line.contains("LocalVariableTable:")) &&
		( line.startsWith(" ")) );
	return line.trim();
    }

    private static String parseFields(Class_ c) 
	throws IOException , InvalidClassFileException 
    {
	String line = br.readLine(); 
	
	while ( ( ! line.contains("(")) &&  // beginning of a method
		( ! line.startsWith("}")) ) // end of class
	{
	    String[] tokens = line.trim().split("\\s+|;");
	    String name;
	    String type;
	    String access = null;
	    int index = 0;
	    if (tokens.length == 3) // there is an  access modifier
	    {
		access = tokens[index];
		index++;
	    }
	    type = tokens[index];
	    name = tokens[index+1];
	    c.addField( new Field_(access, type, name) );
	    
	    line = skipEmptyOrIndentedLines();
	} // loop on fields
	return line;
    }// parseFields method


    private static void parseMethods(String line, Class_ c) 
	throws IOException , InvalidClassFileException 
    {
	int indexOfLeftParen = -1;
	int indexOfRightParen = -1;

	line = line.trim();

	while ( !line.equals( "}") )
	{
	    if (line.trim().equals("static {};"))
		throw new InvalidClassFileException(
                  "Static blocks (including statically initialized arrays)" +
                   " are not supported"
						    );
	    // line is the first line of a method
	    indexOfLeftParen = line.indexOf("(");
	    indexOfRightParen = line.indexOf(")");

	    String parameterTypes = line.substring(indexOfLeftParen+1,
						   indexOfRightParen);
	    line = line.substring( 0, indexOfLeftParen );
	    String[] tokens = line.trim().split("\\s");
	    int n = tokens.length - 1;
	    String name = tokens[n];
	    String modifiers = null;
	    String returnType = null;
	    for(int i=0; i<n; i++) {
		if (isModifier(tokens[i]))
		    if (modifiers==null)
			modifiers = tokens[i];
		    else
			modifiers += " " + tokens[i];
		else
		    returnType = tokens[i];
	    }
	    br.readLine(); // skip "Code:"
	    line = br.readLine().trim();
	    tokens = line.split("\\D+"); 
	    int stackSize = Integer.parseInt( tokens[1] );
	    int numLocals = Integer.parseInt( tokens[2] );
	    int numArgs =   Integer.parseInt( tokens[3] );
		
	    // **********  parse bytecodes ************************
	    ArrayList<String>  bytecodes = new ArrayList<String>();
	    if ( (modifiers != null) && 
		 modifiers.indexOf("abstract") != -1)
		{ // TO DO: handle this error 
		}
	    else // at least one bytecode
		line = br.readLine().trim(); 
	    
	    // assumes that every method has a line number table
	    while (!line.equals("LineNumberTable:")) {
		// assumes that every method has a line number table
		// that immediately follows the bytecodes
		bytecodes.add( line );
		line = br.readLine().trim();
	    }
	    
	    // **********  parse line number table ***************
	    ArrayList<String>  lineNumbers = new ArrayList<String>();
	    line = br.readLine();
	    while ( !line.equals("") ) {
		lineNumbers.add( line );
		line = br.readLine();
	    }
	    int[][] lineNumberTable = new int[lineNumbers.size()][2];
	    for(int i=0; i<lineNumbers.size(); i++) {
		tokens = lineNumbers.get(i).split("\\D+"); 
		lineNumberTable[i][0] = Integer.parseInt( tokens[1] );
		lineNumberTable[i][1] = Integer.parseInt( tokens[2] );
	    }
	    
	    line = skipUntilLVTorNonIndentedLine();

	    if (line.equals("}"))
		break;
	    
	    // **********  parse local variable table ***************
	    String[][] localVars = null;
	    if (line.equals("LocalVariableTable:")) {
		ArrayList<String>  varLines = new ArrayList<String>();
		line = br.readLine(); // skip column headers
		line = br.readLine(); // read in first row of table
		while ( !line.equals("") ) {
		    varLines.add( line );
		    line = br.readLine();
		}
		localVars = new String[ varLines.size() ][3];
		for(int i=0; i<varLines.size(); i++) {
		    tokens = varLines.get(i).split("\\s+");
		    localVars[i][0] = tokens[3];
		    localVars[i][1] = tokens[4];
		    localVars[i][2] = tokens[5];
		}
	    }

	    c.addMethod( new Method_(modifiers, returnType,
				     name, parameterTypes, 
				     stackSize, numLocals, numArgs,
				     bytecodes.toArray( new String[] {}),
				     lineNumberTable, localVars ) );
	    
	    line = skipEmptyOrIndentedLines();
	}// end of current method
    }// parseMethods method
    

    static class ClassNameFilter implements FilenameFilter
    {
	public boolean accept(File dir, String name) {
	    return name.endsWith(".class") &&
		   (new File(dir,name).lastModified() 
		    > GenerateBytecodes.timeStamp);
	}
    }// ClassNameFilter class

    static private boolean isModifier(String s)
    {
	return 
	    s.equals( "abstract" )     ||
	    s.equals( "final" )        ||
	    s.equals( "static" )       ||
	    s.equals( "package" )      ||
	    s.equals( "private" )      ||
	    s.equals( "protected" )    ||
	    s.equals( "public" )       ||
	    s.equals( "synchronized" );
    }// isModifier method


}// GenerateBytecodes  class

class Class_ 
{
    private String modifiers;
    private String packageName;
    private String name;
    private String superClassName;
    private String sourceFileName;
    private ArrayList<Field_> fields;
    ArrayList<Method_> methods;
    public static final String indent = "   ";
    
    Class_(String modifiers, String packageName, 
	   String name, String superClassName )
    {
   // System.out.println(modifiers+" "+packageName+" "+name+" "+superClassName);
	this.modifiers = modifiers;
	this.packageName = packageName;
	this.name = name;
	this.superClassName = superClassName;
	fields = new ArrayList<Field_>();
	methods = new ArrayList<Method_>();
    }

    public void setSourceFileName( String fileName ) 
    {
	sourceFileName = fileName;
    }
    
    public void addField( Field_ f )
    {
  //  System.out.println("addField "+f.name);
	fields.add( f );
    }

    public void addMethod( Method_ m )
    {
 //   System.out.println("addMethod "+m.name);
	methods.add( m );
    }

    public String toString()
    {
	StringBuffer s = 
            new StringBuffer( "// Source file: " + sourceFileName + "\n" );
	s.append( "class " );
	if (packageName != null)
	    s.append( packageName + "." );
	s.append( name );
	s.append( " extends " );
	s.append( superClassName );
	s.append( " {\n" );

	for(Field_ f : fields) {
	    s.append( indent );
	    s.append( f );
	    s.append( "\n" );
	}
	s.append( "\n" );

	for(Method_ m : methods) {
	    s.append( m.toString() );
	    s.append( "\n" );
	}
	s.append( "}\n" );
     
	return s.toString();
    }

}// Class_ class

class Field_
{
    String access;
    String type;
    String name;

    Field_(String access, String type, String name)
    {
    //System.out.println(access+" "+type+" "+name );
	this.access = access;
	this.type = type;
	this.name = name;
    }

    public String toString()
    {
	return ( access != null ? access + " ": "") + type + " " + name + ";";
    }
}// Field_ class

class Method_ 
{
    String name;
    String parameterTypes;
    String returnType;
    String modifiers;
    String[] bytecodes;
    int stackSize, numLocals, numArgs;
    int[][] lineNumberTable;
    String[][] localVariableTable;

    static String indent = Class_.indent;

    Method_(String modifiers, String returnType,
	    String name, String parameterTypes,
	    int stackSize, int numLocals, int numArgs,
	    String[]  bytecodes,
	    int[][] lineNumberTable,
	    String[][] localVariableTable ) {
//System.out.println(modifiers+" "+returnType +" "+name+" "+parameterTypes+" "+stackSize+" "+numLocals+" "+numArgs+" "+bytecodes+" "+lineNumberTable+" "+localVariableTable);

	System.out.println("bytecodes");
	for (int i=0; i<bytecodes.length; i++)
		System.out.print(bytecodes[i]+"---");
	System.out.println("lineNumberTable");
	for (int i=0; i<lineNumberTable.length; i++) {
		for (int j=0; j<lineNumberTable[i].length; j++)
			System.out.print(lineNumberTable[i][j]+"---");
		System.out.println();
	}
	System.out.println("localVariableTable");
	for (int i=0; i<localVariableTable.length; i++) {
		for (int j=0; j<localVariableTable[i].length; j++)
			System.out.print(localVariableTable[i][j]+"---");
		System.out.println();
	}

	this.modifiers = modifiers;
	this.returnType = returnType;
	this.name = name;
	this.parameterTypes = parameterTypes;
	this.stackSize = stackSize;
	this.numLocals = numLocals;
	this.numArgs = numArgs;
	this.bytecodes = bytecodes;
	this.lineNumberTable = lineNumberTable;
	this.localVariableTable = localVariableTable;
    }

    public String toString()
    {
	StringBuffer s =  new StringBuffer();
	if (modifiers != null) {
	    s.append( modifiers );
	    s.append( " " );
	}
	if (returnType != null) {
	    s.append( returnType );
	    s.append( " " );
	}
	s.append( name );
	s.append( "(" );
	s.append( parameterTypes );
	s.append( ")\n" );
	s.append( indent );
	s.append( "stack size = " );
	s.append( stackSize );
	s.append( "\n" );
	s.append( indent );
	s.append( "number of locals = " );
	s.append( numLocals );
	s.append( "\n" );
	s.append( indent );
	s.append( "number of arguments = " );
	s.append( numArgs );
	s.append( "\n" );
	for( String bc : bytecodes ) {
	    s.append( indent );
	    s.append( bc );
	    s.append( "\n" );
	}
	s.append( indent );
	s.append( "LineNumberTable:\n" );
	for(int i=0; i<lineNumberTable.length; i++) {
	    s.append( indent );
	    s.append( lineNumberTable[i][0] );
	    s.append( "\t" );
	    s.append( lineNumberTable[i][1] );
	    s.append( "\n" );
	}
	s.append( indent );
	s.append( "LocalVariableTable:\n" );
	for(int i=0; i<localVariableTable.length; i++) {
	    s.append( indent );
	    s.append( localVariableTable[i][0] );
	    s.append( "\t" );
	    s.append( localVariableTable[i][1] );
	    s.append( "\t" );
	    s.append( localVariableTable[i][2] );
	    s.append( "\n" );
	}
	return s.toString();
    }

}// Method_ class

class InvalidClassFileException extends RuntimeException {

    String errorMessage;

    InvalidClassFileException(String errorMessage) {
	this.errorMessage = errorMessage;
    }

    public String toString() {
	return errorMessage;
    }
}
