/* 
This file is part of JHAVE -- Java Hosted Algorithm Visualization
Environment, developed by Tom Naps, David Furcy (both of the
University of Wisconsin - Oshkosh), Myles McNally (Alma College), and
numerous other contributors who are listed at the http://jhave.org
site

JHAVE is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your
option) any later version.

JHAVE is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with the JHAVE. If not, see:
<http://www.gnu.org/licenses/>.
*/

/** Creates visual representation of a Minimum Spanning Tree using Kruskal's
 *  Algorithm. Usage:
 *  { java Kruskal datFile shoFile }
 *  Where datFile is the name of the .DAT file generated by the kruskal_data
 *  executable included in the directory and shoFile is the name of the 
 *  desired .SHO file. The .DAT file must contain the (x,y)-coordinates of
 *  each node as well as a listing of all node connections and their edge
 *  weights.
 *
 *  @author Tom Naps
 *  @author Alex Zimmerman
 *  @version 2.0
 */

package exe.kruskalalex;

import java.io.*;
import java.util.*;
import exe.*;

/** Implementation of a node in a graph used to demonstrate Kruskal's
 *  Algorithm.
 *
 *  @author Tom Naps
 *  @author Alex Zimmerman
 */
class KNode {
    float x;
    float y;
    int ident;
    boolean add = false;

/** Constructor of the <code>KNode</code> object.
 *
 *  @param x        Horizontal coordinate of the node, generally between
 *                  0 and 1.
 *  @param y        Vertical coordinate of the node, generally between
 *                  0 and 1.
 *  @param i        The set to which the node belongs, used to implement the
 *                  Union-Find logic necessary for Kruskal's algorithm.
 */
    KNode(float xPos, float yPos, int i) {
        x = xPos;
        y = yPos;
        ident = i;
    }

/** Same as above with no parameters.
 */
    KNode() {
        x = 0;
        y = 0;
        ident = 0;
    }
}

/** Implementation of an edge in a graph used to demonstrate Kruskal's
 *  Algorithm.
 *
 *  @author Tom Naps
 *  @author Alex Zimmerman
 */
class KEdge {
    int left;
    int right;
    int weight;
    boolean done = false;
    boolean add = false;
    boolean rejected = false;

/** Constructor for the <code>KEdge</code> object.
 *
 *  @param l        The number of one end node of the edge, arbitrarily
 *                  designated left, as shown on screen. Nodes will be
 *                  displayed numbered from 1 to <code>nodeArray.length</code>.
 *  @param r        The other end node, arbitrarily designated right.
 *  @param w        The edge weight.
 */
    KEdge(int l, int r, int w) {
        left = l;
        right = r;
        weight = w;
    }

/** Same as above, with no parameters.
 */
    KEdge() {
        left = 0;
        right = 0;
        weight = 0;
    }
}

/** Framework for demonstration of Kruskal's Algorithm.
 *
 *  @author Tom Naps
 *  @author Alex Zimmerman
 */
public class Kruskal {
    private PrintWriter out;
    private BufferedReader in;
    private String s;
    private StringTokenizer st;
    private questionCollection questions;
    private int qIndex = 0;
    
/** Creates necessary input and output streams.
 *
 *  @param datFile      The .DAT file from which to read.
 *  @param gaigsFile    The .SHO file to be written.
 *  @throws IOException Error creating file streams.
 */
    public Kruskal(String datFile, String gaigsFile) {
        try {
            s = "";
            in = new BufferedReader(new FileReader(datFile));
            out = new PrintWriter(new BufferedWriter(new FileWriter(gaigsFile)));
            questions = new questionCollection(out);
            st = new StringTokenizer(s);
        } catch(IOException e) {
            e.printStackTrace();
        }
    }

/** Reads data from input file and calls procedure to demonstrate Kruskal's
 *  Algorithm.
 *  File format of .DAT file:
 *  -------------------------
 *  # of nodes   # of connections
 *  GAIGS
 *  1   x-coord of node 1   y-coord of node 1
 *  ...
 *  n   x-coord of node n   y-coord of node n
 *  start node of connection 1   end node of connection 1   weight
 *  ...
 *  start node of connection x   end node of connection x   weight
 *  {EOF}
 *  -------------------------
 *
 *  @param args         Array of command line parameters.
 */
    public static void main(String[] args) {
        try {
            String datFile = args[0];
            String gaigsFile = args[1];
            float xPos, yPos;
            int node1, node2, weight;
            Kruskal graph = new Kruskal(datFile, gaigsFile);
            graph.s = graph.in.readLine();
            graph.st = new StringTokenizer(graph.s);
            int nodeNum = Integer.parseInt(graph.st.nextToken());
            int connNum = Integer.parseInt(graph.st.nextToken());
            KNode[] nodeArray = new KNode[nodeNum];
            graph.s = graph.in.readLine();
            for(int i = 0; i < nodeNum; i++) {
                graph.s = graph.in.readLine();
                graph.st = new StringTokenizer(graph.s);
                xPos = Float.parseFloat(graph.st.nextToken());
                yPos = Float.parseFloat(graph.st.nextToken());
                nodeArray[i] = new KNode(xPos, yPos, i);
            }
            KEdge[] connArray = new KEdge[connNum];
            for(int l = 0; l < connNum; l++) {
                graph.s = graph.in.readLine();
                graph.st = new StringTokenizer(graph.s);
                node1 = Integer.parseInt(graph.st.nextToken());
                node2 = Integer.parseInt(graph.st.nextToken());
                weight = Integer.parseInt(graph.st.nextToken());
                connArray[l] = new KEdge(node1, node2, weight);
            }
            graph.in.close();
            graph.spanTree(nodeArray, connArray);
            graph.questions.writeQuestionsAtEOSF();
            graph.out.close();
        } catch(IOException e) {
            e.printStackTrace();
        }
    }

/** Performs manipulations on data needed to demonstrate Kruskal's Algorithm.
 *  Particular attention must be payed to the boolean properties of the <code>KNode</code>
 *  and <code>KEdge</code> objects, which are used to determine if each node
 *  or edge is currently in the Minimum Spanning Tree, or if an edge has been
 *  discarded as redundant.
 *
 *  @param nodeArray        Array of all nodes in the graph.
 *  @param connArray        Array of all edges in the graph.
 */
    void spanTree(KNode[] nodeArray, KEdge[] connArray) {
        int connections = 0;
        boolean firstTime = true;
        KEdge least = new KEdge();
        for(int i = 0; i < connArray.length; i++) {
            connArray[i].done = false;
            connArray[i].add = false;
	    connArray[i].rejected = false;
        }                    
        printGraph(nodeArray, connArray, 0, 0);
        while(connections < nodeArray.length - 1) {
            for(int m = connArray.length - 1; m >= 0; m--)
                if(!connArray[m].done)
                    least = connArray[m];
            for(int j = 1; j < connArray.length; j++)
                if(connArray[j].weight < least.weight && (!connArray[j].done))
                    least = connArray[j];
            if(firstTime) {
                printGraph(nodeArray, connArray, least.left, least.right);
                firstTime = false;
            }
            least.done = true;
            if(nodeArray[least.left - 1].ident != nodeArray[least.right - 1].ident) {
                connections++;
                least.add = true;
                nodeArray[least.left - 1].add = true;
                nodeArray[least.right - 1].add = true;
                int match = nodeArray[least.right - 1].ident;
                for(int k = 0; k < nodeArray.length; k++)
                    if(nodeArray[k].ident == match)
                        nodeArray[k].ident = nodeArray[least.left - 1].ident;
            }
	    for(int z = 0; z < connArray.length; z++)
		if(connArray[z].done && !connArray[z].add)
		    connArray[z].rejected = true;
            if(connections < nodeArray.length - 1) {
                do {
                    for(int n = connArray.length - 1; n >= 0; n--)
                        if(!connArray[n].done)
                            least = connArray[n];
                    for(int l = 0; l < connArray.length; l++)
                        if(connArray[l].weight < least.weight && (!connArray[l].done))
                            least = connArray[l];
                    if(nodeArray[least.left - 1].ident == nodeArray[least.right - 1].ident) {
			least.done = true;
		    }
                } while(nodeArray[least.left - 1].ident == nodeArray[least.right - 1].ident);
                printGraph(nodeArray, connArray, least.left, least.right);
            }
            else
                printGraph(nodeArray, connArray, 0, 0);
        }
    }

/** Creates a snapshot of the graph.
 *
 *  @param nodeArray        Array of all nodes in the graph.
 *  @param connArray        Array of all edges in the graph.
 *  @param first            One end node of the next edge to be added.
 *                          Use 0 when no question is to be associated
 *                          with the snapshot, or when the tree is complete.
 *  @param second           The other end node of the next edge to be added.
 *                          As above, use 0 if not needed.
 */
    void printGraph(KNode[] nodeArray, KEdge[] connArray, int first, int second) {
        out.println("VIEW DOCS kruskal.htm");
        if(first != 0) {
            fibQuestion q = new fibQuestion(out, (new Integer(qIndex)).toString());
            q.setQuestionText("What will be the vertices of the next edge selected?");
            q.setAnswer("" + first + " " + second);
            q.setAnswer("" + second + " " + first);
            questions.addQuestion(q);
            questions.insertQuestion(qIndex);
            qIndex++;
        }
        out.println("Network");
        out.println("" + 1);
        out.println("Kruskal");
        out.println("***\\***");
        for(int i = 1; i <= nodeArray.length; i++) {
            out.println("" + i + " " + nodeArray[i - 1].x + " " + nodeArray[i - 1].y);
            for(int j = 0; j < connArray.length; j++) {
                if(connArray[j].left == i) {
                    if(connArray[j].add)
                        out.print("\\R");
		    else if(connArray[j].rejected)
			out.print("\\X");
                    else
                        out.print("\\B");
                    out.println("" + connArray[j].right);
                    out.println("" + connArray[j].weight);
                }
                else if(connArray[j].right == i) {
                    if(connArray[j].add)
                        out.print("\\R");
                    else if(connArray[j].rejected)
                        out.print("\\X");
		    else
			out.print("\\B");
                    out.println("" + connArray[j].left);
                    out.println("" + connArray[j].weight);
                }
            }
            out.println("32767");
            if(nodeArray[i - 1].add)
                out.print("\\R");
            else if(first != 0)
                out.print("\\B");
            out.println("" + i);
        }
        out.println("***^***");
    }
}
            
                    
            
            

            
                        
        
        
            
            
            
            
        

    
    
